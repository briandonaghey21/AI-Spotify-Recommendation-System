import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import os
import flask
import dotenv
import flask_cors
import openai
import json 

# set up api keys and such
dotenv.load_dotenv()
app = flask.Flask(__name__)
flask_cors.CORS(app)

SPOTIPY_CLIENT_ID = os.getenv("SPOTIPY_CLIENT_ID")
SPOTIPY_CLIENT_SECRET = os.getenv("SPOTIPY_CLIENT_SECRET")

openai.api_key = os.getenv("OPENAI_KEY")

if not SPOTIPY_CLIENT_ID or not SPOTIPY_CLIENT_SECRET:
    raise ValueError("Missing credentials")

try:
    sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(
        client_id=SPOTIPY_CLIENT_ID,
        client_secret=SPOTIPY_CLIENT_SECRET
    ))
    print("spotify authentication successful!")
except spotipy.SpotifyException as e:
    print("spotify authentication failed:", e)
    exit(1)



# method that searches the spotify api for the song and returns it 
@app.route("/recommend_song", methods=["GET"])
def search():

    # this is actually crazy, open ai sometimes generates hypothetical song names
    query = flask.request.args.get("query")
    if not query:
        return flask.jsonify({"error": "Missing 'query' parameter"}), 400
    prompt =f"Recommend fifteen songs available on spotify based on this user's request in the form and say nothing else. If there is a feature, don't include them in the song title. (Song-Name ; Artist): {query}"
    try:
         songs_info = []
         while len(songs_info) < 10:
            response = openai.ChatCompletion.create(
            model="gpt-4o-mini-2024-07-18",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=300
            )

            print(f"Response to prompt: {prompt} \n{response["choices"][0]["message"]["content"]}")

            lines = response["choices"][0]["message"]["content"].split("\n")

            for recommendation in lines:
                info = recommendation.split(";")
                if len(info) == 2:
                    song = info[0][3:].strip()
                    artist = info[1].strip() 
                    print(f"Verifying '{song}' by '{artist}' exists...")
                    song_info = searchSpotify(song,artist)
                    if (song_info):
                        print("Song successfuly found")
                        songs_info.append(song_info)
                    else:
                        print("Song not found.")
                        logBadSong(song, artist)
                else:
                    print("Skipping Invalid line generated by openAI")
         
         return songs_info
    except Exception as e:
        return flask.jsonify({"error": f"Failed to get song recommendation: {str(e)}"}), 500

# todo: create a cache that puts songs already recommended in it so chatgpt doesnt recommend it and create some sort of database to store wrong songs


         
def searchSpotify(song, artist):
    song_name = song
    artist_name = artist 
    query = f"track:{song_name} artist:{artist_name}"  
    results = sp.search(q=query, limit=1, type="track")
    if results["tracks"]["items"]:
        song = results["tracks"]["items"][0]
        album_images = song["album"]["images"]  
        song_info = {
            "song_name": song["name"],
            "artist": song["artists"][0]["name"],
            "album": song["album"]["name"],
            "spotify_url": song["external_urls"]["spotify"],
            "album_cover": album_images[0]["url"]
        }
        return song_info
    else:
        return None

BAD_SONGS_FILE = "bad_songs.json"
def logBadSong(song, artist):
    try:
        with open(BAD_SONGS_FILE, "r") as f:
            bad_songs = json.load(f)
    except FileNotFoundError:
        bad_songs = []

    for entry in bad_songs:
        if entry["song_name"] == song and entry["artist_name"] == artist:
            return 
        
    bad_songs.append({
        "song_name": song,
        "artist_name": artist,
    })

    with open(BAD_SONGS_FILE, "w") as f:
        json.dump(bad_songs, f, indent=4)

    

if __name__ == "__main__":
    app.run(debug=True)
